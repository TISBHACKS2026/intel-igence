<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cesium — Indiranagar (Terrain + OSM buildings + Rain + Roads)</title>
  <link href="https://cdn.jsdelivr.net/npm/cesium@1.138.0/Build/Cesium/Widgets/widgets.css" rel="stylesheet" />
  <style>
    html,body,#cesiumContainer { width:100%; height:100%; margin:0; padding:0; overflow:hidden; }
    #info { position: absolute; left: 8px; top: 8px; background: rgba(255,255,255,0.9); padding:8px; border-radius:4px; font-family: sans-serif; z-index: 2; }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>
  <div id="info">Initializing...</div>
  <!-- terrainControls removed: auto-reset to Ellipsoid now enabled -->
  <div id="floodControls" style="position:fixed;right:8px;top:8px;z-index:999;background:rgba(255,255,255,0.9);padding:8px;border-radius:4px;font-family: sans-serif;">
    <div style="font-weight:600;margin-bottom:6px">Flood sim (Indiranagar)</div>
    <div style="margin-bottom:6px">Center: <button id="setCenter">Set Center to Camera</button> <button id="pickCenter">Pick Center on map</button></div>
    <div style="margin-bottom:6px"> 
      <div style="font-weight:600;margin-bottom:4px">Location Picker</div>
      <div style="font-size:13px;margin-bottom:4px">Origin: <button id="pickOrigin">Pick Origin on map</button></div>
      <div style="font-size:13px">Destination: <button id="pickDest">Pick Destination on map</button></div>
    </div>
    <div style="margin-bottom:6px">Cell size (m): <input id="cellSize" value="20" style="width:60px"/></div>
    <div style="margin-bottom:6px">Extent (m): <input id="extentSize" value="400" style="width:80px"/> (square)</div>
    <div style="margin-bottom:6px"><button id="buildGrid">Build Grid & Sample Elevation</button> <button id="fetchRegionRoads">Fetch Roads In Region</button></div>
    <div style="margin-bottom:6px"><button id="startFlood">Start Flood</button> <button id="resetFlood">Reset</button></div>
    <div style="margin-bottom:6px">Rain (mm/hr): <input id="waterSlider" type="range" min="0" max="50" step="0.1" value="0" style="width:160px;vertical-align:middle;" disabled/> <span id="waterValue">0.0</span></div>
    <div style="margin-top:6px"><button id="computeRoute">Compute Least-Risk Route</button> <button id="clearRoute">Clear Route</button> <button id="autoDemoRoute">Auto Demo Route</button></div>
    <div id="floodStatus" style="font-size:12px;color:#222;margin-top:6px">idle</div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/cesium@1.138.0/Build/Cesium/Cesium.js"></script>
  <script>
    // === CONFIG ===
    // 1) Replace with your Cesium Ion Access Token
    const CESIUM_ION_TOKEN = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIyZDNiNjU4Yi1mOGM5LTQ3NjEtOWZiYy1lMjhhMzI5ODA3OGEiLCJpZCI6Mzg3ODMxLCJpYXQiOjE3NzAzODU0MDZ9.ESwPwibw8nrZxERbcrLi_H5q_9JMbsamb1_Bo0ig9wI';
    // 2) Backend endpoint returning GeoJSON of roads with `properties.flood_risk` (0..1)
    // Default to the current page origin when served over HTTP so the request
    // is same-origin (avoids CORS). If the page isn't served over HTTP, fall
    // back to the local backend we started at port 5001.
    let ROADS_API_URL;
    if (location && location.protocol && location.protocol.startsWith('http')) {
      ROADS_API_URL = window.location.origin + '/api/roads_flood_risk';
    } else {
      ROADS_API_URL = 'http://localhost:5001/api/roads_flood_risk';
    }

    // Smoothly animate an entity's polyline color from its current color to `targetColor`.
    // `delay` (ms) is an optional stagger before the animation starts.
    function setEntityColorSmooth(ent, targetColor, delay = 0, duration = 600) {
      try {
        // store animation state on the entity to avoid conflicting anims
        if (!ent._colorAnim) ent._colorAnim = { raf: null };
        if (ent._colorAnim.raf) { try { cancelAnimationFrame(ent._colorAnim.raf); } catch (e) {} }

        // try to read current color; if unavailable, pick a default from riskToColor(0)
        let start = [0.0, 0.8, 0.2, 0.95];
        try {
          const curMat = ent.polyline && ent.polyline.material && ent.polyline.material.color ? ent.polyline.material.color.getValue() : null;
          if (curMat && typeof curMat.red === 'number') start = [curMat.red, curMat.green, curMat.blue, curMat.alpha || 0.95];
        } catch (e) {}

        const end = [targetColor.red, targetColor.green, targetColor.blue, targetColor.alpha];
        const dur = duration;
        const t0 = Date.now() + Math.max(0, delay);

        function step() {
          const now = Date.now();
          const dt = Math.min(1, (now - t0) / dur);
          // smoothstep
          const s = dt * dt * (3 - 2 * dt);
          const r = start[0] + (end[0] - start[0]) * s;
          const g = start[1] + (end[1] - start[1]) * s;
          const b = start[2] + (end[2] - start[2]) * s;
          const a = start[3] + (end[3] - start[3]) * s;
          try {
            ent.polyline.material = new Cesium.PolylineGlowMaterialProperty({ color: new Cesium.Color(r, g, b, a) });
          } catch (e) {}
          if (dt < 1 && ent._colorAnim) {
            ent._colorAnim.raf = requestAnimationFrame(step);
          } else if (ent._colorAnim) {
            ent._colorAnim.raf = null;
          }
        }
        ent._colorAnim.raf = requestAnimationFrame(step);
      } catch (e) { /* ignore */ }
    }

    // Basic token sanity check — don't rely on exact placeholder string comparisons.
    if (!CESIUM_ION_TOKEN || typeof CESIUM_ION_TOKEN !== 'string' || CESIUM_ION_TOKEN.length < 20) {
      console.warn('Replace CESIUM_ION_TOKEN with a valid Cesium Ion access token. Using placeholder may fail to load World Terrain.');
    } else {
      console.info('CESIUM_ION_TOKEN appears set (length ' + CESIUM_ION_TOKEN.length + ').');
    }

    Cesium.Ion.defaultAccessToken = CESIUM_ION_TOKEN;

    // update info box to reflect token + backend URL state
    (function updateInfoBox() {
      const info = document.getElementById('info');
      const tokenLooksSet = CESIUM_ION_TOKEN && !CESIUM_ION_TOKEN.startsWith('YOUR_') && CESIUM_ION_TOKEN.length > 20;
      const backend = ROADS_API_URL;
      if (tokenLooksSet) {
        info.innerHTML = 'Cesium token set. Terrain exaggeration 1.5x. Road feed: <b>' + backend + '</b>';
        info.innerHTML += '<br><button id="loadIonBtn">Load Ion 3D Tiles (asset id)</button> <button id="loadUrlBtn">Load 3D-Tiles URL</button>';
      } else {
        info.innerHTML = 'Missing Cesium token — set <b>CESIUM_ION_TOKEN</b> in the file. Road feed: <b>' + backend + '</b>';
      }
    })();

    // Wire buttons for loading 3D tiles at runtime
    function loadIonTileset(assetId) {
      const info = document.getElementById('info');
      try {
        const resource = Cesium.IonResource.fromAssetId(Number(assetId));
        const tileset = new Cesium.Cesium3DTileset({ url: resource });
        tileset.readyPromise.then(() => {
          viewer.scene.primitives.add(tileset);
          console.info('Loaded Ion tileset asset', assetId);
          info.innerHTML += '<br>Loaded Ion tileset: ' + assetId;
        }).catch(err => {
          console.warn('Ion tileset readyPromise rejected', err);
          info.innerHTML += '<br style="color:red">Failed to load Ion tileset: ' + err;
        });
      } catch (e) {
        console.warn('Failed to load Ion tileset', e);
        info.innerHTML += '<br style="color:red">Failed to load Ion tileset: ' + e;
      }
    }

    function loadTilesetUrl(url) {
      const info = document.getElementById('info');
      try {
        const tileset = new Cesium.Cesium3DTileset({ url: url });
        tileset.readyPromise.then(() => {
          viewer.scene.primitives.add(tileset);
          console.info('Loaded tileset URL', url);
          info.innerHTML += '<br>Loaded tileset URL: ' + url;
        }).catch(err => {
          console.warn('Tileset URL failed to load', err);
          info.innerHTML += '<br style="color:red">Failed to load tileset URL: ' + err;
        });
      } catch (e) {
        console.warn('Failed to construct tileset', e);
        info.innerHTML += '<br style="color:red">Failed to construct tileset: ' + e;
      }
    }

    document.addEventListener('click', function (e) {
      if (e.target && e.target.id === 'loadIonBtn') {
        const id = prompt('Enter Cesium Ion asset ID (numeric) to load 3D-tiles:');
        if (id) loadIonTileset(id.trim());
      }
      if (e.target && e.target.id === 'loadUrlBtn') {
        const url = prompt('Enter 3D-tiles tileset.json URL:');
        if (url) loadTilesetUrl(url.trim());
      }
    });

    // Coordinates for Indiranagar, Bengaluru (approx)
    let CENTER = { lon: 77.6406, lat: 12.9719, height: 2500 };

    // Create World Terrain and viewer (with safe fallback if helper missing)
    let terrainProvider;
    if (typeof Cesium.createWorldTerrain === 'function') {
      terrainProvider = Cesium.createWorldTerrain({ requestVertexNormals: false });
    } else {
      try {
        // Fallback: construct a CesiumTerrainProvider using Ion resource id 1 (World Terrain)
        const ionResource = Cesium.IonResource.fromAssetId(1);
        terrainProvider = new Cesium.CesiumTerrainProvider({ url: ionResource });
        console.info('Using CesiumTerrainProvider fallback for World Terrain.');
      } catch (e) {
        console.warn('World Terrain helper unavailable and fallback failed — using ellipsoid terrain.', e);
        terrainProvider = new Cesium.EllipsoidTerrainProvider();
      }
    }

    const viewer = new Cesium.Viewer('cesiumContainer', {
      terrainProvider: terrainProvider,
      timeline: false,
      animation: false,
      baseLayerPicker: true,
      sceneModePicker: true,
      geocoder: false,
      homeButton: true,
      infoBox: false,
      selectionIndicator: false
    });
    // expose viewer for console and runtime controls
    window.viewer = viewer;

    // Auto-reset terrain to Ellipsoid so the demo starts in the known working state
    try {
      viewer.terrainProvider = new Cesium.EllipsoidTerrainProvider();
      const infoEl = document.getElementById('info');
      if (infoEl) infoEl.innerHTML += '<br>Terrain: Ellipsoid (auto)';
    } catch (e) { console.warn('Failed to auto-reset terrain to Ellipsoid', e); }

    // Ensure there's a visible base imagery layer even if Ion imagery is unavailable
    try {
      // Remove any pre-existing imagery layers (some builds include a default layer that may not be reachable),
      // then add OpenStreetMap as the single base layer to ensure tiles appear.
      try { viewer.imageryLayers.removeAll(); } catch (e) { console.warn('Failed to remove existing imagery layers', e); }

      // Add OpenStreetMap as a reliable fallback base layer
      const osmLayer = viewer.imageryLayers.addImageryProvider(new Cesium.OpenStreetMapImageryProvider({ url: 'https://a.tile.openstreetmap.org/' }));
      // Ensure the OSM layer is visible and fully opaque
      osmLayer.alpha = 1.0;
      osmLayer.show = true;
      viewer.imageryLayers.raiseToTop(osmLayer);
      console.info('Added OpenStreetMap imagery fallback', osmLayer);
      try { console.info('OSM provider ready (ready flag):', !!(osmLayer.imageryProvider && osmLayer.imageryProvider.ready)); } catch (e) {}

      // If provider exposes a readyPromise, log when it resolves or rejects
      try {
        const prov = osmLayer.imageryProvider;
        if (prov && prov.readyPromise) {
          prov.readyPromise.then(() => console.info('OSM provider.readyPromise resolved (provider ready)')).catch(err => console.warn('OSM provider.readyPromise rejected', err));
        }
      } catch (e) { console.warn('Error inspecting osm provider readyPromise', e); }

      // Diagnostic: try loading a sample OSM tile as an Image to detect network/CORS/load issues
      try {
        const testTile = new Image();
        testTile.crossOrigin = 'anonymous';
        testTile.onload = () => console.info('Test OSM tile loaded OK (image onload)');
        testTile.onerror = (ev) => console.warn('Test OSM tile failed to load (image onerror)', ev);
        // Example tile near our center at zoom 10 — may vary by viewport
        testTile.src = 'https://a.tile.openstreetmap.org/10/548/382.png';
      } catch (e) { console.warn('Failed to create test image for OSM tile', e); }
    } catch (e) {
      console.warn('Failed to add OpenStreetMap imagery fallback', e);
    }

    // Debug: list imagery layers/providers present
    try {
      console.group('Imagery layers');
      for (let i = 0; i < viewer.imageryLayers.length; i++) {
        const lyr = viewer.imageryLayers.get(i);
        const prov = lyr && lyr.imageryProvider;
        console.log('layer', i, { providerConstructor: prov && prov.constructor && prov.constructor.name, provider: prov, ready: prov && prov.ready });
      }
      console.groupEnd();
    } catch (e) {
      console.warn('Imagery layer inspection failed', e);
    }

    // Slight terrain exaggeration (1.5x)
    // Some Cesium builds don't support terrainExaggeration; guard the assignment.
    if (viewer.scene && viewer.scene.globe && 'terrainExaggeration' in viewer.scene.globe) {
      try { viewer.scene.globe.terrainExaggeration = 1.5; } catch (e) { console.warn('Failed to set terrainExaggeration', e); }
    } else {
      console.info('terrainExaggeration not supported by this Cesium build; skipping.');
    }

    // Center camera at Indiranagar
    viewer.camera.setView({
      destination: Cesium.Cartesian3.fromDegrees(CENTER.lon, CENTER.lat, CENTER.height),
      orientation: {
        heading: Cesium.Math.toRadians(0.0),
        pitch: Cesium.Math.toRadians(-45.0),
        roll: 0.0
      }
    });

    // Ensure globe is shown and nudge camera lower for better visibility
    try { viewer.scene.globe.show = true; } catch (e) {}
    try { viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(CENTER.lon, CENTER.lat, 800), duration: 1.2 }); } catch (e) {}

    // Add OSM 3D buildings (Cesium helper)
    try {
      const osm = Cesium.createOsmBuildings();
      viewer.scene.primitives.add(osm);
    } catch (e) {
      console.warn('createOsmBuildings() not available in this build; skip OSM 3D buildings.', e);
    }

    // Ensure there is at least one visible base imagery (so Reset shows a textured globe)
    try {
      if (!viewer.imageryLayers || viewer.imageryLayers.length === 0) {
        viewer.imageryLayers.addImageryProvider(new Cesium.OpenStreetMapImageryProvider({ url: 'https://a.tile.openstreetmap.org/' }));
      }
    } catch (e) { console.warn('Failed to ensure OSM imagery in main viewer', e); }

    // --- Animated rain using ParticleSystem ---
    // Create a small circular raindrop image via canvas
    function makeDropImage() {
      const c = document.createElement('canvas');
      c.width = 8; c.height = 20; const ctx = c.getContext('2d');
      // blue vertical drop
      ctx.fillStyle = 'rgba(180,200,255,0.9)';
      ctx.beginPath(); ctx.ellipse(4,8,2,6,0,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = 'rgba(200,220,255,0.4)'; ctx.fillRect(3,0,2,8);
      return c.toDataURL();
    }

    const dropImage = makeDropImage();

    // We'll add a particle system that spans a box above the center and emits particles that fall down.
    function addRain() {
      const centerCartesian = Cesium.Cartesian3.fromDegrees(CENTER.lon, CENTER.lat, 2000);
      const modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(centerCartesian);

      const boxSize = new Cesium.Cartesian3(20000.0, 20000.0, 1.0); // 20km x 20km area

      const rain = new Cesium.ParticleSystem({
        image: dropImage,
        startColor: new Cesium.Color(0.7,0.8,1.0,0.9),
        endColor: new Cesium.Color(0.7,0.8,1.0,0.0),
        startScale: 1.0,
        endScale: 1.0,
        minimumSpeed: 1500.0,
        maximumSpeed: 3500.0,
        minimumLife: 3.0,
        maximumLife: 6.0,
        imageSize: new Cesium.Cartesian2(8,20),
        emissionRate: 1500.0,
        emitter: new Cesium.BoxEmitter(boxSize),
        modelMatrix: modelMatrix
      });

      // Override particle update so particles fall straight down (world Z)
      rain.updateCallback = function(particle, dt) {
        // If velocity not yet set to downward, set it once
        if (!particle._downwardInit) {
          particle._downwardInit = true;
          // set downward velocity in local model space: negative Z
          const speed = Cesium.Math.lerp(rain.minimumSpeed, rain.maximumSpeed, Math.random());
          particle.velocity = new Cesium.Cartesian3(0.0, 0.0, -speed);
        }
        // integrate position using particle.velocity
        const delta = Cesium.Cartesian3.multiplyByScalar(particle.velocity, dt, new Cesium.Cartesian3());
        particle.position = Cesium.Cartesian3.add(particle.position, delta, new Cesium.Cartesian3());
      };

      viewer.scene.primitives.add(rain);
    }

    addRain();

    // --- Overlay roads as polylines and color based on flood risk ---
    // Map flood risk (0..1) to a smooth gradient: green -> orange -> red
    // Use eased interpolation so mid-range (orange) is more visible and
    // color changes are gradual. We compress the scale slightly so
    // low->mid transitions are more visible.
    function riskToColor(r) {
      r = Math.max(0, Math.min(1, r));
      // ease the value to emphasize mid-range (use gamma < 1 to push values up)
      const t = Math.pow(r, 0.7);
      // endpoints
      const green = [0.0, 0.8, 0.2];
      const orange = [1.0, 0.6, 0.0];
      const red = [1.0, 0.0, 0.0];

      let from, to, localT;
      if (t <= 0.5) { from = green; to = orange; localT = t / 0.5; }
      else { from = orange; to = red; localT = (t - 0.5) / 0.5; }
      // smoothstep for smoother visual transition
      localT = localT * localT * (3 - 2 * localT);
      const rr = from[0] + (to[0] - from[0]) * localT;
      const gg = from[1] + (to[1] - from[1]) * localT;
      const bb = from[2] + (to[2] - from[2]) * localT;
      return new Cesium.Color(rr, gg, bb, 0.95);
    }

    // Maintain a map of feature id -> entity
    const roadEntities = new Map();

    async function fetchAndUpdateRoads() {
      try {
        // Compute bbox around CENTER using the current extentSize (meters)
        const extentMeters = Number(document.getElementById('extentSize') ? document.getElementById('extentSize').value : 400) || 400;
        const halfMeters = extentMeters / 2.0;
        const degHalf = halfMeters / 111320.0;
        const south = CENTER.lat - degHalf;
        const north = CENTER.lat + degHalf;
        const west = CENTER.lon - degHalf;
        const east = CENTER.lon + degHalf;

        // Fetch geometry from roads_bbox for the computed bbox
        const geomRes = await fetch('/api/roads_bbox', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ bbox: [west, south, east, north] }) });
        if (!geomRes.ok) throw new Error('roads_bbox HTTP ' + geomRes.status);
        const geomJson = await geomRes.json();

        // Fetch risk mappings filtered to this bbox (backend returns dict when bbox provided)
        const bboxStr = [west, south, east, north].join(',');
        // include current rain value if set so periodic updater doesn't overwrite manual slider
        const currentRain = (typeof floodState.rain_mm === 'number') ? floodState.rain_mm : 0.0;
        const riskRes = await fetch('/api/roads_risk?bbox=' + encodeURIComponent(bboxStr) + '&rain_mm=' + encodeURIComponent(currentRain), { cache: 'no-store' });
        let riskMap = new Map();
        if (riskRes.ok) {
          const rj = await riskRes.json();
          if (rj && rj.roads) {
            // support both array (legacy) and object/dict (new)
            if (Array.isArray(rj.roads)) {
              for (const r of rj.roads) {
                if (r && r.id != null) {
                  riskMap.set(String(r.id), { risk: Number(r.risk) || 0.0, avg_elevation: (r.avg_elevation != null ? Number(r.avg_elevation) : null) });
                }
              }
            } else {
              for (const key in rj.roads) {
                const r = rj.roads[key];
                const rid = (r && r.id != null) ? String(r.id) : String(key);
                if (rid) {
                  riskMap.set(rid, { risk: Number(r && r.risk) || 0.0, avg_elevation: (r && r.avg_elevation != null ? Number(r.avg_elevation) : null) });
                }
              }
            }
          }
        }

        const geojson = geomJson;
        if (!geojson || !geojson.features) return;

        // Add or update features, applying risk from riskMap when available
        for (const feat of geojson.features) {
          if (!feat.geometry || feat.geometry.type !== 'LineString') continue;
          const coords = feat.geometry.coordinates;
          const positions = [];
          for (const c of coords) {
            const h = (c[2] || 0) + 8.0;
            positions.push(Cesium.Cartesian3.fromDegrees(c[0], c[1], h));
          }

          const id = String(feat.id || (feat.properties && feat.properties.id) || JSON.stringify(coords).slice(0,40));
          const riskEntry = (riskMap.has(id)) ? riskMap.get(id) : null;
          const risk = riskEntry ? riskEntry.risk : (feat.properties && typeof feat.properties.flood_risk === 'number' ? feat.properties.flood_risk : 0.0);
          const avg_elevation = riskEntry ? (riskEntry.avg_elevation != null ? riskEntry.avg_elevation : null) : (feat.properties && feat.properties.avg_elevation ? Number(feat.properties.avg_elevation) : null);
          const color = riskToColor(risk);

          if (roadEntities.has(id)) {
            const ent = roadEntities.get(id);
            ent.polyline.material = new Cesium.ColorMaterialProperty(color);
            ent.polyline.positions = positions;
            ent.properties && (ent.properties.flood_risk = risk);
            // keep original coords and avg_elevation for flood testing
            try { ent.properties.origCoords = coords; ent.properties.avg_elevation = avg_elevation; } catch (e) {}
          } else {
            const ent = viewer.entities.add({
              id: id,
              polyline: {
                positions: positions,
                width: 6.0,
                material: new Cesium.PolylineGlowMaterialProperty({ color: color.withAlpha(0.95) }),
                clampToGround: false,
                depthFailMaterial: new Cesium.PolylineGlowMaterialProperty({ color: color.withAlpha(0.6) })
              },
              label: {
                text: id,
                font: '14px sans-serif',
                fillColor: Cesium.Color.WHITE,
                style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                outlineColor: Cesium.Color.BLACK,
                outlineWidth: 2,
                pixelOffset: new Cesium.Cartesian2(0, -12),
                disableDepthTestDistance: Number.POSITIVE_INFINITY
              },
              properties: {
                flood_risk: risk,
                origCoords: coords,
                avg_elevation: avg_elevation
              }
            });
            roadEntities.set(id, ent);
          }
        }

        try {
          const info = document.getElementById('info');
          info.innerHTML = 'Loaded ' + geojson.features.length + ' road features (bbox). Road feed: <b>/api/roads_bbox + /api/roads_risk</b>';
        } catch (e) {}

        console.info('Updated roads — entities:', roadEntities.size, 'viewer.entities:', viewer.entities.values.length);
      } catch (err) {
        console.warn('Failed to fetch roads:', err);
        try { document.getElementById('info').innerHTML = 'Failed to load roads: ' + (err && err.message || err); } catch(e){}
      }
    }

    // Fetch roads specifically for a bbox (used after grid built) and replace displayed roads
    async function fetchRoadsForBoxAndSave(west, south, east, north) {
      try {
        const geomRes = await fetch('/api/roads_bbox', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ bbox: [west, south, east, north] }) });
        if (!geomRes.ok) throw new Error('roads_bbox HTTP ' + geomRes.status);
        const geomJson = await geomRes.json();

        const bboxStr = [west, south, east, north].join(',');
        const currentRain = (typeof floodState.rain_mm === 'number') ? floodState.rain_mm : 0.0;
        const riskRes = await fetch('/api/roads_risk?bbox=' + encodeURIComponent(bboxStr) + '&rain_mm=' + encodeURIComponent(currentRain), { cache: 'no-store' });
        let riskMap = new Map();
        let riskArray = [];
        if (riskRes.ok) {
          const rj = await riskRes.json();
          if (rj && rj.roads) {
            if (Array.isArray(rj.roads)) {
              riskArray = rj.roads;
              for (const r of rj.roads) {
                if (r && r.id != null) riskMap.set(String(r.id), { risk: Number(r.risk) || 0.0, avg_elevation: (r.avg_elevation != null ? Number(r.avg_elevation) : null) });
              }
            } else {
              // dict form
              for (const key in rj.roads) {
                const r = rj.roads[key];
                const rid = (r && r.id != null) ? String(r.id) : String(key);
                if (rid) {
                  riskMap.set(rid, { risk: Number(r && r.risk) || 0.0, avg_elevation: (r && r.avg_elevation != null ? Number(r.avg_elevation) : null) });
                  riskArray.push(r);
                }
              }
            }
          }
        }

        // Remove all existing road entities and re-add only those inside bbox
        for (const ent of roadEntities.values()) { try { viewer.entities.remove(ent); } catch(e){} }
        roadEntities.clear();

        for (const feat of geomJson.features || []) {
          if (!feat.geometry || feat.geometry.type !== 'LineString') continue;
          const coords = feat.geometry.coordinates;
          const positions = [];
          for (const c of coords) positions.push(Cesium.Cartesian3.fromDegrees(c[0], c[1], (c[2] || 0) + 8.0));
          const id = String(feat.id || (feat.properties && feat.properties.id) || JSON.stringify(coords).slice(0,40));
          if (!riskMap.has(id)) continue; // skip ways that don't have risk record for this bbox
          const re = riskMap.get(id);
          const color = riskToColor(re.risk || 0.0);
          const ent = viewer.entities.add({ id: id, polyline: { positions, width: 6.0, material: new Cesium.PolylineGlowMaterialProperty({ color: color.withAlpha(0.95) }) }, properties: { flood_risk: re.risk, origCoords: coords, avg_elevation: re.avg_elevation } });
          roadEntities.set(id, ent);
        }

        // Persist filtered risk array to backend so backend/roads_with_risk.json contains only this area
        try {
          await fetch('/api/save_roads_risk', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ roads: riskArray }) });
        } catch (e) { console.warn('failed to save roads risk to backend', e); }

        document.getElementById('info').innerHTML = 'Loaded ' + roadEntities.size + ' roads for grid bbox and saved to backend/roads_with_risk.json';
      } catch (e) {
        console.error('fetchRoadsForBoxAndSave failed', e);
        document.getElementById('floodStatus').textContent = 'Failed to fetch roads for grid: ' + (e && e.message);
      }
    }

    // Initial fetch and periodic updates
    fetchAndUpdateRoads();
    setInterval(fetchAndUpdateRoads, 5000); // poll every 5s

    // Location / feature click handler — supports pick-mode for origin/destination
    let _pickMode = null; // 'origin' | 'dest' | null
    let _originEntity = null, _destEntity = null;

    function _createOrUpdateMarker(which, lon, lat) {
      try {
        const id = (which === 'origin') ? 'marker-origin' : 'marker-dest';
        const existing = viewer.entities.getById(id);
        const pos = Cesium.Cartesian3.fromDegrees(lon, lat, 8);
        const color = (which === 'origin') ? Cesium.Color.CYAN : Cesium.Color.MAGENTA;
        if (existing) {
          existing.position = pos;
          existing.label.text = (which === 'origin') ? 'Origin' : 'Destination';
        } else {
          viewer.entities.add({ id: id, position: pos, point: { pixelSize: 14, color: color, outlineColor: Cesium.Color.WHITE, outlineWidth: 2 }, label: { text: (which === 'origin') ? 'Origin' : 'Destination', font: '14px sans-serif', fillColor: Cesium.Color.WHITE, style: Cesium.LabelStyle.FILL_AND_OUTLINE, outlineColor: Cesium.Color.BLACK, outlineWidth: 2, pixelOffset: new Cesium.Cartesian2(0, -18) } });
        }
      } catch (e) { console.warn('marker create failed', e); }
    }

    function setOriginFromCoords(lon, lat) {
      const oLon = document.getElementById('originLon');
      const oLat = document.getElementById('originLat');
      if (oLon) oLon.value = lon.toFixed(5);
      if (oLat) oLat.value = lat.toFixed(5);
      _createOrUpdateMarker('origin', lon, lat);
      try { viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(lon, lat, 800), duration: 0.8 }); } catch (e) {}
    }

    function setDestinationFromCoords(lon, lat) {
      const dLon = document.getElementById('destLon');
      const dLat = document.getElementById('destLat');
      if (dLon) dLon.value = lon.toFixed(5);
      if (dLat) dLat.value = lat.toFixed(5);
      _createOrUpdateMarker('dest', lon, lat);
      try { viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(lon, lat, 800), duration: 0.8 }); } catch (e) {}
    }

    viewer.screenSpaceEventHandler.setInputAction(function(click) {
      // If we're in pick mode, set origin/destination from clicked position on globe
      if (_pickMode) {
        try {
          const cart = viewer.camera.pickEllipsoid(click.position, viewer.scene.globe.ellipsoid);
          if (!cart) { document.getElementById('floodStatus').textContent = 'Click on globe surface to pick a point'; return; }
          const carto = Cesium.Cartographic.fromCartesian(cart);
          const lon = Cesium.Math.toDegrees(carto.longitude);
          const lat = Cesium.Math.toDegrees(carto.latitude);
          if (_pickMode === 'origin') setOriginFromCoords(lon, lat);
          else if (_pickMode === 'dest') setDestinationFromCoords(lon, lat);
          else if (_pickMode === 'center') {
            CENTER.lon = lon; CENTER.lat = lat;
            try { viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(CENTER.lon, CENTER.lat, CENTER.height), duration: 1.0 }); } catch (e) {}
            document.getElementById('floodStatus').textContent = 'center set: ' + lon.toFixed(5) + ', ' + lat.toFixed(5);
          }
          _pickMode = null;
          document.getElementById('floodStatus').textContent = 'Picked ' + (carto && carto.height ? 'point' : '') + ' — pick mode cleared';
        } catch (e) { console.warn('pick failed', e); }
        return;
      }

      // default behavior: show road info when clicking on polylines/entities
      const picked = viewer.scene.pick(click.position);
      if (Cesium.defined(picked) && Cesium.defined(picked.id) && picked.id.properties) {
        const p = picked.id.properties;
        alert('Road ID: ' + picked.id.id + '\nFlood risk: ' + (p.flood_risk || 0));
      }
    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

    // Draggable marker support: allow dragging origin/destination markers
    let _dragging = { active: false, id: null };
    viewer.screenSpaceEventHandler.setInputAction(function(click) {
      // LEFT_DOWN: start drag if clicked marker
      try {
        const picked = viewer.scene.pick(click.position);
        if (Cesium.defined(picked) && Cesium.defined(picked.id) && (picked.id.id === 'marker-origin' || picked.id.id === 'marker-dest')) {
          _dragging.active = true;
          _dragging.id = picked.id.id;
          // consume interaction
          document.getElementById('floodStatus').textContent = 'Dragging ' + (_dragging.id === 'marker-origin' ? 'origin' : 'destination');
        }
      } catch (e) { console.warn('drag start failed', e); }
    }, Cesium.ScreenSpaceEventType.LEFT_DOWN);

    viewer.screenSpaceEventHandler.setInputAction(function(movement) {
      // MOUSE_MOVE: if dragging, update marker position to current mouse location on globe
      if (!_dragging.active) return;
      try {
        const cart = viewer.camera.pickEllipsoid(movement.endPosition, viewer.scene.globe.ellipsoid);
        if (!cart) return;
        const carto = Cesium.Cartographic.fromCartesian(cart);
        const lon = Cesium.Math.toDegrees(carto.longitude);
        const lat = Cesium.Math.toDegrees(carto.latitude);
        if (_dragging.id === 'marker-origin') {
          _createOrUpdateMarker('origin', lon, lat);
          const oLon = document.getElementById('originLon');
          const oLat = document.getElementById('originLat');
          if (oLon) oLon.value = lon.toFixed(5);
          if (oLat) oLat.value = lat.toFixed(5);
        } else if (_dragging.id === 'marker-dest') {
          _createOrUpdateMarker('dest', lon, lat);
          const dLon = document.getElementById('destLon');
          const dLat = document.getElementById('destLat');
          if (dLon) dLon.value = lon.toFixed(5);
          if (dLat) dLat.value = lat.toFixed(5);
        }
      } catch (e) { console.warn('drag move failed', e); }
    }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

    viewer.screenSpaceEventHandler.setInputAction(function() {
      // LEFT_UP: stop dragging
      if (_dragging.active) {
        document.getElementById('floodStatus').textContent = 'Drag complete';
      }
      _dragging.active = false; _dragging.id = null;
    }, Cesium.ScreenSpaceEventType.LEFT_UP);

    // Helpful console message
    console.log('Cesium viewer initialized. Center:', CENTER);

    // Flood simulation state
    const floodState = { cells: [], waterLevel: null, animId: null, playing: false };

    function metersToDegrees(lat, meters) {
      const latDeg = meters / 111320.0;
      const lonDeg = meters / (111320.0 * Math.cos(Cesium.Math.toRadians(lat)));
      return { latDeg, lonDeg };
    }

    // Build grid over CENTER with given cell size and extent (meters)
    async function buildGridAndSample(cellSizeM, extentM) {
      const status = document.getElementById('floodStatus');
      status.textContent = 'building grid...';
      // compute grid dims
      const half = extentM / 2.0;
      const degsHalf = metersToDegrees(CENTER.lat, half);
      const lat0 = CENTER.lat - degsHalf.latDeg;
      const lon0 = CENTER.lon - degsHalf.lonDeg;
      const cols = Math.max(2, Math.floor(extentM / cellSizeM));
      const rows = cols;
      const cellLatSize = metersToDegrees(CENTER.lat, cellSizeM).latDeg;
      const cellLonSize = metersToDegrees(CENTER.lat, cellSizeM).lonDeg;

      const points = [];
      const cells = [];
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const centerLat = lat0 + (r + 0.5) * cellLatSize;
          const centerLon = lon0 + (c + 0.5) * cellLonSize;
          points.push([centerLon, centerLat]);
          cells.push({ r, c, centerLon, centerLat });
        }
      }

      status.textContent = 'sampling ' + points.length + ' points...';
      try {
        const res = await fetch('/api/elevation', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ points }) });
        const json = await res.json();
        const elevs = json.elevations || [];
        // create entities for each cell
        // clear previous
        for (const s of floodState.cells) { if (s.entity) viewer.entities.remove(s.entity); }
        floodState.cells = [];

        for (let i = 0; i < cells.length; i++) {
          const cell = cells[i];
          const elev = elevs[i] != null ? elevs[i] : 0;
          // rectangle corners
          const halfLat = cellLatSize / 2.0;
          const halfLon = cellLonSize / 2.0;
          const west = cell.centerLon - halfLon;
          const east = cell.centerLon + halfLon;
          const south = cell.centerLat - halfLat;
          const north = cell.centerLat + halfLat;
          const entity = viewer.entities.add({
            polygon: {
              hierarchy: Cesium.Cartesian3.fromDegreesArray([west, south, east, south, east, north, west, north]),
              material: Cesium.Color.BLUE.withAlpha(0.25),
              height: elev,
              extrudedHeight: elev,
              outline: false
            }
          });
          // store cell bounds for spatial tests later
          floodState.cells.push({ entity, elev, west, east, south, north });
        }

        floodState.waterLevel = Math.min(...floodState.cells.map(s => s.elev));
        // draw region bounding box entity so user sees the selected area
        try {
          const halfLat = cellLatSize * rows / 2.0;
          const halfLon = cellLonSize * cols / 2.0;
          const south = lat0;
          const north = lat0 + rows * cellLatSize;
          const west = lon0;
          const east = lon0 + cols * cellLonSize;
          // remove existing
          if (floodState.regionBox && floodState.regionBox.entity) viewer.entities.remove(floodState.regionBox.entity);
          const rectEnt = viewer.entities.add({
            rectangle: {
              coordinates: Cesium.Rectangle.fromDegrees(west, south, east, north),
              material: Cesium.Color.BLUE.withAlpha(0.08),
              outline: true,
              outlineColor: Cesium.Color.BLUE
            }
          });
          floodState.regionBox = { entity: rectEnt, west, south, east, north };
        } catch (e) { console.warn('failed to draw region box', e); }
        // After building region box, fetch only roads for this bbox and persist them
        try {
          fetchRoadsForBoxAndSave(west, south, east, north);
        } catch (e) { console.warn('failed to fetch/save roads for bbox', e); }
            const minE = Math.min(...floodState.cells.map(s => s.elev));
            const maxE = Math.max(...floodState.cells.map(s => s.elev));
            // enable and configure slider
            try {
              const slider = document.getElementById('waterSlider');
              const val = document.getElementById('waterValue');
              if (slider && val) {
                // slider now controls rainfall (mm/hr)
                slider.disabled = false;
                slider.min = 0;
                slider.max = 50;
                slider.step = 0.1;
                slider.value = 0;
                val.textContent = '0.0';
              }
            } catch (e) {}
            status.textContent = 'grid built. elevation range: ' + minE.toFixed(2) + ' — ' + maxE.toFixed(2);
      } catch (e) {
        console.error('elevation sampling failed', e);
        status.textContent = 'sampling failed: ' + (e && e.message);
      }
    }

    function updateFloodVisuals(waterLevel) {
      for (const s of floodState.cells) {
        const base = s.elev || 0;
        const extrude = Math.max(base, waterLevel);
        try { s.entity.polygon.extrudedHeight = extrude; s.entity.polygon.height = base; } catch (e) {}
      }
      // After updating cell extrusion, also update road colors to reflect flooded cells
      try { updateRoadColorsByFlood(); } catch (e) {}
    }

    function startFloodAnimation() {
      if (floodState.playing) return;
      if (!floodState.cells.length) { document.getElementById('floodStatus').textContent = 'no grid — build first'; return; }
      floodState.playing = true;
      const minE = Math.min(...floodState.cells.map(s => s.elev));
      const maxE = Math.max(...floodState.cells.map(s => s.elev));
      const target = maxE + 10; // rise a bit above highest
      let level = minE - 1;
      const speed = 0.5; // meters per frame approx
      function step() {
        level += speed;
        floodState.waterLevel = level;
        updateFloodVisuals(level);
        document.getElementById('floodStatus').textContent = 'water level: ' + level.toFixed(2) + ' m';
        if (level < target && floodState.playing) floodState.animId = requestAnimationFrame(step);
        else { floodState.playing = false; document.getElementById('floodStatus').textContent += ' — done'; }
      }
      floodState.animId = requestAnimationFrame(step);
    }

    function resetFlood() {
      floodState.playing = false;
      if (floodState.animId) cancelAnimationFrame(floodState.animId);
      floodState.animId = null;
      for (const s of floodState.cells) {
        try { s.entity.polygon.extrudedHeight = s.elev; s.entity.polygon.height = s.elev; } catch (e) {}
      }
      document.getElementById('floodStatus').textContent = 'reset';
      // clear manual water level so updateRoadColorsByFlood treats as no water
      try { floodState.waterLevel = null; } catch (e) {}
      // reset slider
      try {
        const slider = document.getElementById('waterSlider');
        const val = document.getElementById('waterValue');
        if (slider && val) { slider.disabled = true; slider.value = 0; val.textContent = '0.0'; }
      } catch (e) {}
      try { updateRoadColorsByFlood(); } catch (e) {}
    }

    // wire UI
    document.getElementById('buildGrid').addEventListener('click', function() {
      const cellSizeM = Number(document.getElementById('cellSize').value) || 20;
      const extentM = Number(document.getElementById('extentSize').value) || 400;
      buildGridAndSample(cellSizeM, extentM);
    });
    document.getElementById('startFlood').addEventListener('click', startFloodAnimation);
    document.getElementById('resetFlood').addEventListener('click', resetFlood);

    // set center handler (update CENTER and fly camera)
    try {
      const setBtn = document.getElementById('setCenter');
      if (setBtn) {
        setBtn.addEventListener('click', function() {
          try {
            const carto = Cesium.Cartographic.fromCartesian(viewer.camera.position);
            const lon = Cesium.Math.toDegrees(carto.longitude);
            const lat = Cesium.Math.toDegrees(carto.latitude);
            if (Number.isNaN(lon) || Number.isNaN(lat)) { document.getElementById('floodStatus').textContent = 'Unable to determine camera center'; return; }
            CENTER.lon = lon; CENTER.lat = lat;
            try { viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(CENTER.lon, CENTER.lat, CENTER.height), duration: 1.0 }); } catch (e) {}
            document.getElementById('floodStatus').textContent = 'center set: ' + lon.toFixed(5) + ', ' + lat.toFixed(5);
          } catch (e) { console.warn('set center failed', e); }
        });
      }
    } catch (e) { console.warn('Failed to wire setCenter button', e); }

    // wire origin/destination buttons
    try {
      const pickCenterBtn = document.getElementById('pickCenter');
      const setOriginBtn = document.getElementById('setOrigin');
      const pickOriginBtn = document.getElementById('pickOrigin');
      const setDestBtn = document.getElementById('setDest');
      const pickDestBtn = document.getElementById('pickDest');
      if (setOriginBtn) setOriginBtn.addEventListener('click', function() {
        const lon = parseFloat(document.getElementById('originLon').value);
        const lat = parseFloat(document.getElementById('originLat').value);
        if (Number.isNaN(lon) || Number.isNaN(lat)) { alert('Invalid origin coordinates'); return; }
        setOriginFromCoords(lon, lat);
      });
      if (setDestBtn) setDestBtn.addEventListener('click', function() {
        const lon = parseFloat(document.getElementById('destLon').value);
        const lat = parseFloat(document.getElementById('destLat').value);
        if (Number.isNaN(lon) || Number.isNaN(lat)) { alert('Invalid destination coordinates'); return; }
        setDestinationFromCoords(lon, lat);
      });
      if (pickCenterBtn) pickCenterBtn.addEventListener('click', function() { _pickMode = 'center'; document.getElementById('floodStatus').textContent = 'Pick center: click on the map'; });
      if (pickOriginBtn) pickOriginBtn.addEventListener('click', function() { _pickMode = 'origin'; document.getElementById('floodStatus').textContent = 'Pick origin: click on the map'; });
      if (pickDestBtn) pickDestBtn.addEventListener('click', function() { _pickMode = 'dest'; document.getElementById('floodStatus').textContent = 'Pick destination: click on the map'; });
    } catch (e) { console.warn('Failed to wire origin/destination buttons', e); }

    // wire compute/clear route buttons
    try {
      const computeBtn = document.getElementById('computeRoute');
      const clearBtn = document.getElementById('clearRoute');
    const autoBtn = document.getElementById('autoDemoRoute');
      if (computeBtn) computeBtn.addEventListener('click', async function() {
        // require both origin and dest markers
        const origEnt = viewer.entities.getById('marker-origin');
        const destEnt = viewer.entities.getById('marker-dest');
        if (!origEnt || !destEnt) { document.getElementById('floodStatus').textContent = 'Place both origin and destination markers first'; return; }
        try {
          const opos = origEnt.position.getValue(Cesium.JulianDate.now());
          const dpos = destEnt.position.getValue(Cesium.JulianDate.now());
          const oCarto = Cesium.Cartographic.fromCartesian(opos);
          const dCarto = Cesium.Cartographic.fromCartesian(dpos);
          const olon = Cesium.Math.toDegrees(oCarto.longitude), olat = Cesium.Math.toDegrees(oCarto.latitude);
          const dlon = Cesium.Math.toDegrees(dCarto.longitude), dlat = Cesium.Math.toDegrees(dCarto.latitude);
          document.getElementById('floodStatus').textContent = 'Computing least-risk route...';

          // Compute route; allow computeLeastRiskRoute to build/fetch a temp graph
          document.getElementById('floodStatus').textContent = 'Computing least-risk route...';
          const path = await computeLeastRiskRoute(olon, olat, dlon, dlat);
          if (path && path.length) {
            _drawRoute(path);
            document.getElementById('floodStatus').textContent = 'Route drawn (' + path.length + ' nodes) — graph nodes: ' + nodesCount + ', origin≈' + distO + 'm dest≈' + distD + 'm';
          } else {
            document.getElementById('floodStatus').textContent = 'No route found — graph nodes: ' + nodesCount + ', origin≈' + distO + 'm dest≈' + distD + 'm';
          }
        } catch (e) { console.warn('compute route failed', e); document.getElementById('floodStatus').textContent = 'Route compute error: ' + (e && e.message); }
      });
      if (clearBtn) clearBtn.addEventListener('click', function() { _clearRoute(); document.getElementById('floodStatus').textContent = 'Route cleared'; });
      if (autoBtn) autoBtn.addEventListener('click', async function() {
        // choose a sensible demo bbox / origin/dest near the current center
        try {
          document.getElementById('floodStatus').textContent = 'Running auto demo route...';
          const deg = m => m / 111320.0;
          const half = 200;
          const south = CENTER.lat - deg(half);
          const north = CENTER.lat + deg(half);
          const west = CENTER.lon - deg(half);
          const east = CENTER.lon + deg(half);
          // small offset origins within bbox
          const origin = [CENTER.lon - deg(20), CENTER.lat];
          const dest = [CENTER.lon + deg(20), CENTER.lat];
          const res = await fetch('/api/route_networkx', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ bbox: [west, south, east, north], origin: origin, dest: dest, penalty: 5.0 }) });
          if (!res.ok) { document.getElementById('floodStatus').textContent = 'Auto demo failed: server error'; return; }
          const j = await res.json();
          if (!j || !Array.isArray(j.path) || !j.path.length) { document.getElementById('floodStatus').textContent = 'Auto demo: no path returned'; return; }
          _drawRoute(j.path);
          document.getElementById('floodStatus').textContent = 'Auto demo route drawn (' + j.path.length + ' nodes)';
        } catch (e) { console.warn('auto demo failed', e); document.getElementById('floodStatus').textContent = 'Auto demo error'; }
      });
    } catch (e) { console.warn('Failed to wire route buttons', e); }

    // wire water slider for manual control
    try {
      const slider = document.getElementById('waterSlider');
      const val = document.getElementById('waterValue');
      if (slider && val) {
        slider.addEventListener('input', function() {
          // Stop any running animation when the user takes manual control
          if (floodState.playing) {
            floodState.playing = false;
            if (floodState.animId) {
              try { cancelAnimationFrame(floodState.animId); } catch (e) {}
              floodState.animId = null;
            }
            document.getElementById('floodStatus').textContent = 'manual control (animation stopped)';
          }

          const level = Number(slider.value);
          val.textContent = level.toFixed(2);
          // store rain (mm/hr) separately from waterLevel used for flood extrusion
          floodState.rain_mm = level;
          document.getElementById('floodStatus').textContent = 'manual rain: ' + level.toFixed(2) + ' mm/hr';
          // Debounced update: send rain (mm/hr) to backend and refresh risks
          try { scheduleRiskUpdateFromRain(level); } catch (e) { console.warn('risk update schedule failed', e); }
        });
      }
    } catch (e) { console.warn('Failed to wire water slider', e); }

    // Update road colors based on flooded cells
    function updateRoadColorsByFlood() {
      if (!floodState || !floodState.cells || floodState.cells.length === 0) return;
      const waterLevel = floodState.waterLevel;
      // build list of flooded cell bounds
      const flooded = [];
      if (waterLevel != null) {
        for (const c of floodState.cells) {
          if (waterLevel > (c.elev || 0)) flooded.push(c);
        }
      }

      for (const [id, ent] of roadEntities) {
        try {
          const coords = (ent.properties && ent.properties.origCoords) ? ent.properties.origCoords : null;
          // Prefer per-road avg elevation when available
          const roadElev = (ent.properties && (ent.properties.avg_elevation != null)) ? Number(ent.properties.avg_elevation) : null;
          let isFlooded = false;
          if (coords && flooded.length) {
            for (const pt of coords) {
              const lon = pt[0], lat = pt[1];
              for (const c of flooded) {
                if (lon >= c.west && lon <= c.east && lat >= c.south && lat <= c.north) {
                  if (roadElev != null) {
                    if (waterLevel > roadElev) { isFlooded = true; }
                  } else {
                    // fallback: if the cell elevation is below water level, mark flooded
                    if ((c.elev || 0) < waterLevel) { isFlooded = true; }
                  }
                  break;
                }
              }
              if (isFlooded) break;
            }
          }
          try {
            // Stagger color changes slightly per-entity so not everything flips at once.
            // Use a deterministic small delay based on id so updates look organic.
            const seed = (function(s) {
              let h = 0; for (let i=0;i<s.length;i++) h = ((h<<5)-h)+s.charCodeAt(i); return Math.abs(h);
            })(String(id));
            const delay = seed % 250; // 0..249 ms stagger
            const duration = 600; // longer interpolation for smoother change
            if (isFlooded) {
              const red = Cesium.Color.RED.withAlpha(0.95);
              setEntityColorSmooth(ent, red, delay, duration);
            } else {
              const risk = (ent.properties && typeof ent.properties.flood_risk === 'number') ? ent.properties.flood_risk : 0.0;
              const color = riskToColor(risk);
              setEntityColorSmooth(ent, color, delay, duration);
            }
          } catch (e) { /* ignore update errors */ }
        } catch (e) { /* ignore entity update errors */ }
      }
    }

    // --- Risk update helpers: fetch recomputed risks from backend using rain (mm/hr) ---
    let _riskUpdateTimer = null;
    function scheduleRiskUpdateFromRain(rain_mm) {
      if (_riskUpdateTimer) clearTimeout(_riskUpdateTimer);
      _riskUpdateTimer = setTimeout(() => { updateRisksFromRain(rain_mm); _riskUpdateTimer = null; }, 250);
    }

    async function updateRisksFromRain(rain_mm) {
      try {
        const url = '/api/roads_risk?rain_mm=' + encodeURIComponent(rain_mm);
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) { console.warn('roads_risk fetch failed', res.status); return; }
        const j = await res.json();
        const arr = j && j.roads ? (Array.isArray(j.roads) ? j.roads : Object.values(j.roads)) : [];
        // Update in-memory entities' flood_risk properties
        for (const r of arr) {
          const rid = String(r && (r.id != null ? r.id : r && r['id']));
          if (!rid) continue;
          if (roadEntities.has(rid)) {
            const ent = roadEntities.get(rid);
            try { ent.properties = ent.properties || {}; ent.properties.flood_risk = Number(r.risk) || 0.0; ent.properties.avg_elevation = r.avg_elevation != null ? Number(r.avg_elevation) : ent.properties.avg_elevation; } catch (e) {}
          }
        }
        // refresh colors after applying new risks
        try { updateRoadColorsByFlood(); } catch (e) {}
      } catch (e) { console.warn('updateRisksFromRain error', e); }
    }

    // --- Least-risk routing (client-side) ---
    // Build a graph from `roadEntities`. Nodes are distinct coordinate points
    // (rounded). Edges are consecutive polyline segments weighted by length*(1+risk*5).
    function _buildGraphFromRoads() {
      const nodes = new Map();
      function keyFor(lon, lat) { return lon.toFixed(5) + ',' + lat.toFixed(5); }

      for (const [id, ent] of roadEntities) {
        try {
          const coords = (ent.properties && ent.properties.origCoords) ? ent.properties.origCoords : null;
          const risk = (ent.properties && typeof ent.properties.flood_risk === 'number') ? Number(ent.properties.flood_risk) : 0.0;
          if (!coords || coords.length < 2) continue;
          for (let i = 0; i < coords.length - 1; i++) {
            const a = coords[i]; const b = coords[i+1];
            const ka = keyFor(a[0], a[1]); const kb = keyFor(b[0], b[1]);
            if (!nodes.has(ka)) nodes.set(ka, { coord: [a[0], a[1]], edges: [] });
            if (!nodes.has(kb)) nodes.set(kb, { coord: [b[0], b[1]], edges: [] });
            // compute length in meters using Cesium distance
            const pA = Cesium.Cartesian3.fromDegrees(a[0], a[1], 0);
            const pB = Cesium.Cartesian3.fromDegrees(b[0], b[1], 0);
            const len = Cesium.Cartesian3.distance(pA, pB) || 1.0;
            const weight = len * (1.0 + risk * 5.0);
            nodes.get(ka).edges.push({ to: kb, weight: weight, coord: [b[0], b[1]] });
            nodes.get(kb).edges.push({ to: ka, weight: weight, coord: [a[0], a[1]] });
          }
        } catch (e) { /* skip bad */ }
      }
      return nodes;
    }

    function _findNearestNode(nodes, lon, lat) {
      let best = null; let bestDist = Infinity;
      const p = Cesium.Cartesian3.fromDegrees(lon, lat, 0);
      for (const [k, v] of nodes) {
        const c = v.coord; const pc = Cesium.Cartesian3.fromDegrees(c[0], c[1], 0);
        const d = Cesium.Cartesian3.distance(p, pc);
        if (d < bestDist) { bestDist = d; best = k; }
      }
      return { key: best, dist: bestDist };
    }

    async function computeLeastRiskRoute(originLon, originLat, destLon, destLat) {
      // Try server-side NetworkX route first (fast when available)
      try {
        const extentM = Number(document.getElementById('extentSize') ? document.getElementById('extentSize').value : 400) || 400;
        const half = extentM / 2.0;
        const deg = m => m / 111320.0;
        const south = CENTER.lat - deg(half);
        const north = CENTER.lat + deg(half);
        const west = CENTER.lon - deg(half);
        const east = CENTER.lon + deg(half);
        const body = { bbox: [west, south, east, north], origin: [originLon, originLat], dest: [destLon, destLat], penalty: 5.0 };
        const res = await fetch('/api/route_networkx', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
        if (res.ok) {
          const j = await res.json();
          if (j && Array.isArray(j.path) && j.path.length) {
            return j.path;
          }
        }
      } catch (e) {
        console.warn('server-side route failed, falling back to client routing', e);
      }

      let nodes = _buildGraphFromRoads();
      // If no client-side roadEntities are loaded, fetch geometry+risks for a bbox
      // around the current center/extent and build a temporary graph so routing still works.
      if (!nodes || nodes.size === 0) {
        try {
          const extentM = Number(document.getElementById('extentSize') ? document.getElementById('extentSize').value : 400) || 400;
          const half = extentM / 2.0;
          const deg = m => m / 111320.0;
          const south = CENTER.lat - deg(half);
          const north = CENTER.lat + deg(half);
          const west = CENTER.lon - deg(half);
          const east = CENTER.lon + deg(half);
          document.getElementById('floodStatus').textContent = 'Loading roads for routing (this may take a moment)...';
          const geomRes = await fetch('/api/roads_bbox', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ bbox: [west, south, east, north] }) });
          if (!geomRes.ok) { document.getElementById('floodStatus').textContent = 'Failed to load road geometry'; return null; }
          const geomJson = await geomRes.json();
          const rainArg = encodeURIComponent((typeof floodState.rain_mm === 'number') ? floodState.rain_mm : 0.0);
          const riskRes = await fetch('/api/roads_risk?bbox=' + encodeURIComponent([west, south, east, north].join(',')) + '&rain_mm=' + rainArg, { cache: 'no-store' });
          let riskMap = new Map();
          if (riskRes.ok) {
            const rj = await riskRes.json();
            if (rj && rj.roads) {
              if (Array.isArray(rj.roads)) {
                for (const r of rj.roads) if (r && r.id != null) riskMap.set(String(r.id), r);
              } else {
                for (const key in rj.roads) { const r = rj.roads[key]; const rid = (r && r.id != null) ? String(r.id) : String(key); riskMap.set(rid, r); }
              }
            }
          }
          // Build nodes from fetched geometry + riskMap
          const temp = new Map();
          function keyFor(lon, lat) { return lon.toFixed(5) + ',' + lat.toFixed(5); }
          for (const feat of (geomJson.features || [])) {
            try {
              if (!feat.geometry || feat.geometry.type !== 'LineString') continue;
              const coords = feat.geometry.coordinates;
              const id = String(feat.id || (feat.properties && feat.properties.id) || JSON.stringify(coords).slice(0,40));
              const r = riskMap.has(id) ? riskMap.get(id) : (feat.properties && feat.properties.flood_risk != null ? { risk: Number(feat.properties.flood_risk) } : { risk: 0.0 });
              const riskVal = (r && r.risk != null) ? Number(r.risk) : 0.0;
              for (let i = 0; i < coords.length - 1; i++) {
                const a = coords[i], b = coords[i+1];
                const ka = keyFor(a[0], a[1]); const kb = keyFor(b[0], b[1]);
                if (!temp.has(ka)) temp.set(ka, { coord: [a[0], a[1]], edges: [] });
                if (!temp.has(kb)) temp.set(kb, { coord: [b[0], b[1]], edges: [] });
                const pA = Cesium.Cartesian3.fromDegrees(a[0], a[1], 0);
                const pB = Cesium.Cartesian3.fromDegrees(b[0], b[1], 0);
                const len = Cesium.Cartesian3.distance(pA, pB) || 1.0;
                const weight = len * (1.0 + riskVal * 5.0);
                temp.get(ka).edges.push({ to: kb, weight: weight, coord: [b[0], b[1]] });
                temp.get(kb).edges.push({ to: ka, weight: weight, coord: [a[0], a[1]] });
              }
            } catch (e) { /* ignore */ }
          }
          nodes = temp;
        } catch (e) {
          console.warn('failed to fetch/build temp road graph', e);
          document.getElementById('floodStatus').textContent = 'Failed to build temporary road graph';
          return null;
        }
      }
      const o = _findNearestNode(nodes, originLon, originLat);
      const d = _findNearestNode(nodes, destLon, destLat);
      if (!o.key || !d.key) { document.getElementById('floodStatus').textContent = 'Could not find nearby road nodes'; return null; }

      // Dijkstra
      const dist = new Map(); const prev = new Map();
      for (const k of nodes.keys()) { dist.set(k, Infinity); prev.set(k, null); }
      dist.set(o.key, 0);
      const Q = new Set(nodes.keys());
      while (Q.size) {
        // find minimal dist in Q
        let u = null; let uDist = Infinity;
        for (const k of Q) { const dv = dist.get(k); if (dv < uDist) { uDist = dv; u = k; } }
        if (u === null) break;
        Q.delete(u);
        if (u === d.key) break;
        const node = nodes.get(u);
        if (!node) continue;
        for (const e of node.edges) {
          if (!Q.has(e.to)) continue;
          const alt = uDist + e.weight;
          if (alt < dist.get(e.to)) { dist.set(e.to, alt); prev.set(e.to, u); }
        }
      }

      if (!prev.get(d.key) && o.key !== d.key) { document.getElementById('floodStatus').textContent = 'No path found'; return null; }
      const path = [];
      let cur = d.key; while (cur) { const n = nodes.get(cur); if (n) path.push(n.coord); cur = prev.get(cur); }
      path.reverse();
      return path;
    }

    function _drawRoute(pathCoords) {
      // remove existing
      try { const existing = viewer.entities.getById('least-risk-route'); if (existing) viewer.entities.remove(existing); } catch (e) {}
      if (!pathCoords || pathCoords.length === 0) return;
      const positions = pathCoords.map(p => Cesium.Cartesian3.fromDegrees(p[0], p[1], 8));
      viewer.entities.add({ id: 'least-risk-route', polyline: { positions: positions, width: 8.0, material: new Cesium.PolylineGlowMaterialProperty({ color: Cesium.Color.CYAN, glowPower: 0.25 }), clampToGround: false } });
    }

    function _clearRoute() { try { const e = viewer.entities.getById('least-risk-route'); if (e) viewer.entities.remove(e); } catch (e) {} }

    // END
  </script>

  <script>
    // Fetch roads in the current CENTER + extent and draw them
    (function() {
      const btn = document.getElementById('fetchRegionRoads');
      const statusEl = document.getElementById('floodStatus');
      const regionRoads = new Map();

      async function fetchRegion() {
        const extentM = Number(document.getElementById('extentSize').value) || 400;
        const half = extentM / 2.0;
        const degsHalf = metersToDegrees(CENTER.lat, half);
        const south = CENTER.lat - degsHalf.latDeg;
        const north = CENTER.lat + degsHalf.latDeg;
        const west = CENTER.lon - degsHalf.lonDeg;
        const east = CENTER.lon + degsHalf.lonDeg;
        statusEl.textContent = 'Fetching roads from backend...';
        try {
          // Use roads_risk to retrieve only roads in bbox (with risk metadata) and geometry from roads_bbox
          const geomRes = await fetch('/api/roads_bbox', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ bbox: [west, south, east, north] }) });
          if (!geomRes.ok) throw new Error('roads_bbox HTTP ' + geomRes.status);
          const geojson = await geomRes.json();

          const bboxStr = [west, south, east, north].join(',');
          const riskRes = await fetch('/api/roads_risk?bbox=' + encodeURIComponent(bboxStr), { cache: 'no-store' });
          let riskMap = new Map();
          let riskArray = [];
          if (riskRes.ok) {
            const rj = await riskRes.json();
            if (rj && rj.roads) {
              if (Array.isArray(rj.roads)) {
                riskArray = rj.roads;
                for (const r of rj.roads) { if (r && r.id != null) riskMap.set(String(r.id), r); }
              } else {
                for (const key in rj.roads) { const r = rj.roads[key]; const rid = (r && r.id != null) ? String(r.id) : String(key); riskMap.set(rid, r); riskArray.push(r); }
              }
            }
          }

          // clear previous region roads
          for (const r of regionRoads.values()) { viewer.entities.remove(r); }
          regionRoads.clear();
          let count = 0;
          for (const feat of geojson.features || []) {
            if (!feat.geometry || feat.geometry.type !== 'LineString') continue;
            const coords = feat.geometry.coordinates;
            const id = String(feat.id || (feat.properties && feat.properties.id) || JSON.stringify(coords).slice(0,40));
            if (!riskMap.has(id)) continue;
            const r = riskMap.get(id);
            const positions = coords.map(c => Cesium.Cartesian3.fromDegrees(c[0], c[1], 8));
            const mat = riskToColor(Number(r.risk) || 0.0);
            const ent = viewer.entities.add({ id: 'region-'+id, polyline: { positions, width: 4.0, material: new Cesium.PolylineGlowMaterialProperty({ color: mat.withAlpha(0.95) }) } });
            regionRoads.set(id, ent);
            count++;
          }
          statusEl.textContent = 'Fetched ' + count + ' roads';

          // persist filtered risk array
          try { await fetch('/api/save_roads_risk', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ roads: riskArray }) }); } catch (e) { console.warn('save failed', e); }
        } catch (e) {
          console.error('Failed to fetch region roads', e);
          statusEl.textContent = 'Failed to fetch roads: ' + (e && e.message);
        }
      }

      if (btn) btn.addEventListener('click', fetchRegion);
    })();
  </script>

  <!-- Terrain control script removed: terrain now auto-resets to Ellipsoid on load -->
</body>
</html>
